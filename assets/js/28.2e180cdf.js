(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{113:function(v,s,r){"use strict";r.r(s);var _=r(2),a=Object(_.a)({},(function(){var v=this,s=v.$createElement,r=v._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("p",[v._v("内存中的数据具有易失性，为防止数据丢失，Redis有两种数据持久化机制：RDB与AOF。")]),v._v(" "),r("h2",{attrs:{id:"rdb"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[v._v("#")]),v._v(" RDB")]),v._v(" "),r("h3",{attrs:{id:"rdb持久化简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rdb持久化简介"}},[v._v("#")]),v._v(" RDB持久化简介")]),v._v(" "),r("p",[v._v("RDB指redis的"),r("strong",[v._v("快照储存方式（snapshotting）")]),v._v("。进行rdb持久化时，redis会将所有数据序列化到一个rdb文件中（默认为dump.rdb），在下一次redis-server启动时，会自动加载文件中的数据，实现数据持久化。")]),v._v(" "),r("p",[v._v("rdb持久化可以通过显式命令"),r("code",[v._v("save")]),v._v("与"),r("code",[v._v("bgsave")]),v._v("执行：")]),v._v(" "),r("p",[r("code",[v._v("save")]),v._v("执行时会占用server主进程，此时server将拒绝其他client请求直到持久化完成，因此在生产环境中应尽量避免使用"),r("code",[v._v("save")]),v._v("方式进行rdb持久化；")]),v._v(" "),r("p",[r("code",[v._v("bgsave")]),v._v("会"),r("strong",[v._v("fork一个子进程")]),v._v("执行rdbSave函数进行实际的快照存储工作，而父进程可以继续处理客户端请求。当子进程退出后，父进程调用相关回调函数进行后续处理。")]),v._v(" "),r("p",[v._v("另外，redis也可以通过配置文件的方式定时启动rdb持久化：")]),v._v(" "),r("div",{staticClass:"language-ini line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-ini"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# redis.conf")]),v._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 表示如果60秒内写数据超过1000次，则执行rdb持久化")]),v._v("\nsave 60 1000\n")])]),v._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[v._v("1")]),r("br"),r("span",{staticClass:"line-number"},[v._v("2")]),r("br"),r("span",{staticClass:"line-number"},[v._v("3")]),r("br")])]),r("h3",{attrs:{id:"rdb持久化优缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rdb持久化优缺点"}},[v._v("#")]),v._v(" RDB持久化优缺点")]),v._v(" "),r("p",[v._v("优点：")]),v._v(" "),r("ol",[r("li",[r("strong",[v._v("对主进程无影响")]),v._v("。RDB持久化由子进程完成，父进程无需任何磁盘IO操作，对服务无影响；")]),v._v(" "),r("li",[r("strong",[v._v("速度快")]),v._v("。RDB文件的恢复比AOF文件要快；")]),v._v(" "),r("li",[r("strong",[v._v("便于储存和管理")]),v._v("。RDB只生成一个文件，方便运维人员进行管理。")])]),v._v(" "),r("p",[v._v("缺点：")]),v._v(" "),r("ol",[r("li",[r("p",[v._v("RDB持久化最主要的缺点就是"),r("strong",[v._v("可能会出现数据丢失的问题")]),v._v("。由于RDB持久化有间隔时间，当间隔时间内发生宕机时，此部分数据便会丢失，因此RDB持久化适用于可以容忍部分数据丢失的场景；")])]),v._v(" "),r("li",[r("p",[v._v("另外，虽然RDB持久化过程对主进程没有影响。但是如果Redis内存数据过大，fork时复制内存的时间就会过长，也会造成服务暂时性无响应。")])])]),v._v(" "),r("h2",{attrs:{id:"aof"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[v._v("#")]),v._v(" AOF")]),v._v(" "),r("h3",{attrs:{id:"aof简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aof简介"}},[v._v("#")]),v._v(" AOF简介")]),v._v(" "),r("p",[v._v("AOF全称是Append Only File，即追加文件持久化。")]),v._v(" "),r("p",[v._v("AOF持久化机制是将所有收到的"),r("strong",[v._v("写命令")]),v._v("都记录在一个文件中（默认"),r("code",[v._v("appendonly.aof")]),v._v("），当redis-server重启时，就可以按照文件中的写命令一步一步还原redis数据。")]),v._v(" "),r("p",[v._v("AOF机制理论上不会丢失任何数据，但是由于IO写缓存的存在，如果恰巧某一条命令刚写入缓存区还未同步至文件时发生了崩溃，则会丢失此次数据。可以设置配置文件调整缓存同步频率（默认为1秒，可以调整为每次）。")]),v._v(" "),r("h3",{attrs:{id:"aof优缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aof优缺点"}},[v._v("#")]),v._v(" AOF优缺点")]),v._v(" "),r("p",[v._v("优点：")]),v._v(" "),r("ol",[r("li",[r("strong",[v._v("高可靠性")]),v._v("。AOF持久化机制相比RDB更加可靠，即使是默认的文件同步频率依然保证了数据持久化的可靠性；")]),v._v(" "),r("li",[r("strong",[v._v("可读性")]),v._v("。RDB持久化使用特定序列化方法储存数据，且采用二进制方式储存文件，文件不具备可读性；而AOF持久化记录的是每条写命令，运维人员可以直接读取AOF文件，进行数据维护工作。")])]),v._v(" "),r("p",[v._v("缺点：")]),v._v(" "),r("ol",[r("li",[v._v("文件体积较大，且恢复速度缓慢；")]),v._v(" "),r("li",[v._v("AOF在恢复过程可能存在一些bug，导致无法完全恢复数据，而RDB没有这种问题。")])])])}),[],!1,null,null,null);s.default=a.exports}}]);